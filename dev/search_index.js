var documenterSearchIndex = {"docs":
[{"location":"theory/vope/#Computations-for-VOPE-coupling","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"","category":"section"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"As in the case of VAPE coupling, the exact computations of the UPDATE step depend on the nature of the coupling with the child node(s), while both the PE step and the PREDICTION step depend on the coupling with the parent node(s).","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"To describe the computations entailed by VOPE coupling, we will introduce two changes to the notation. First of all, we will express the volatility PE, or VOPE, as a function of the previously defined value PE, or VAPE. That means from now on, we will use the character delta_i only for VAPEs:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{equation} \\deltai^{(k)} \\equiv \\deltai^{(k, VAPE)} = \\mui^{(k)} - \\hat{\\mu}i^{(k)}, \\end{equation} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"and introduce a new character Delta_i for VOPEs, which we define as","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{equation}   \\begin{split}     \\Deltai^{(k)} \\equiv \\deltai^{(k, VOPE)} &= \\frac{ \\frac{1}{\\pi{i}^{(k)}} + (\\mui^{(k)} - \\hat{\\mu}i^{(k)})^2 }{ \\frac{1}{\\pi{i}^{(k-1)}} + \\nu{i}^{(k)} } - 1 \\\n    &= \\hat{\\pi}i^{(k)} \\left( \\frac{1}{\\pi{i}^{(k)}} + (\\mui^{(k)} - \\hat{\\mu}i^{(k)})^2 \\right) - 1 \\\n    &= \\hat{\\pi}i^{(k)} \\left( \\frac{1}{\\pi{i}^{(k)}} + (\\deltai^{(k)})^2 \\right) - 1 \\\n    &=  \\frac{\\hat{\\pi}i^{(k)}}{\\pi{i}^{(k)}} + \\hat{\\pi}i^{(k)} (\\deltai^{(k)})^2 - 1. \\\n  \\end{split} \\end{equation} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Note that from the first to the second line, we have used the following definition:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{equation} \\hat{\\pi}{i-1}^{(k)} = \\frac{1}{ \\frac{1}{\\pi{i-1}^{(k-1)}} + \\nu_{i-1}^{(k)} }. \\end{equation} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"This ensures that a given node does not need to have access to the posterior precision from the level below: pi_i-1^(k-1), which facilitates implementation.","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"In sum, we are introducing a second prediction error unit Delta_i which is concerned with deviations from predicted uncertainty and is informed by value prediction errors and other estimates of uncertainty. It is this prediction error - a function of the unweighted (squared) value prediction error with a new precision weight - which communicates between a level's nodes and a level's volatility parent's nodes.","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Second, we will introduce another quantity, which we term the (auxiliary) expected precision","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{equation} \\gammai^{(k)} = \\nui^{(k)} \\hat{\\pi}_i^{(k)}, \\end{equation} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"which will be computed as part of the PREDICTION step and only serves to simplify the equations and the corresponding message passing.","category":"page"},{"location":"theory/vope/#Update-Step","page":"Computations for VOPE coupling","title":"Update Step","text":"","category":"section"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"If Node i is the volatility parent of Node i-1, then the following update equations apply to Node i:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{align*} \\pii^{(k)} &= \\hat{\\pi}i^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{1}{2}(\\kappa{i-1} \\nu{i-1}^{(k)} \\hat{\\pi}_{i-1}^{(k)})^2\n(1 + (1 - \\frac{1}{\\pi{i-1}^{(k-1)} \\nu{i-1}^{(k)}})","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\delta{i-1}^{(k)})\\\n&= \\hat{\\pi}i^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{1}{2}(\\kappa{i-1} \\nu{i-1}^{(k)} \\hat{\\pi}_{i-1}^{(k)})^2\n(1 + (2 - \\frac{1}{\\hat{\\pi}{i-1}^{(k)} \\nu{i-1}^{(k)}})","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\delta{i-1}^{(k)})\\\n\\mui^{(k)} &= \\hat{\\mu}_i^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{1}{2}\\kappa{i-1} \\nu{i-1}^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{\\hat{\\pi}{i-1}^{(k)}}{\\pi{i}^{(k)}} \\delta_{i-1}^{(k)}, \\end{align*} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"where we have again used the definition of the predicted precision hatpi_i-1^(k) to derive an expression for the posterior precision from the previous trial pi_i-1^(k-1):","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{align} \\hat{\\pi}{i-1}^{(k)} &= \\frac{1}{ \\frac{1}{\\pi{i-1}^{(k-1)}} + \\nu{i-1}^{(k)} }\\\n\\Leftrightarrow \\pi{i-1}^{(k-1)} &= \\frac{1}{ \\frac{1}{\\hat{\\pi}{i-1}^{(k)}} - \\nu{i-1}^{(k)} }. \\end{align} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"With the changes from above, namely the definitions of the \\textsf{VOPE} Delta_i and the expected precision gamma_i^(k), the update equations for the precision and the mean in volatility coupling simplify to: \\vspace{0.5cm}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{align} \\pii^{(k)} &= \\hat{\\pi}i^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{1}{2} (\\kappa{i,i-1} \\gamma{i-1}^{(k)})^2\n(\\kappa{i,i-1} \\gamma{i-1}^{(k)})^2 \\Delta_{i-1}^{(k)}\n\\frac{1}{2} \\kappa{i,i-1}^2 \\gamma{i-1}^{(k)} \\Delta_{i-1}^{(k)}\\\n","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\mui^{(k)} &= \\hat{\\mu}i^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\frac{1}{2} \\frac{\\kappa{i,i-1} \\gamma{i-1}^{(k)}}{\\pii^{(k)}} \\Delta{i-1}^{(k)}","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\end{align} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Therefore, at the time of the update, Node i needs to have access to the following quantities:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Its own predictions: hatmu_i^(k), hatpi_i^(k)\nCoupling strength: kappa_ii-1\nFrom level below: Delta_i-1^(k), gamma_i-1^(k)","category":"page"},{"location":"theory/vope/#Prediction-Error-Step","page":"Computations for VOPE coupling","title":"Prediction Error Step","text":"","category":"section"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"The exact computation of the prediction error depends, like the computation of the new prediction, on the nature of the coupling with the parent nodes. We will therefore assume in the following, that Node i is the volatility child of Node i+1. Then the following quantities have to be sent up to Node i+1 (see also necessary information from level below in a volatility parent):","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Expected precision: gamma_i^(k)\nPrediction error: Delta_i^(k)","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Node i has already performed the \\textsf{PREDICTION step} on the previous trial, so it has already computed the predicted precision, hatpi_i^(k), and the volatiliy estimate, nu_i^(k), and out of these the expected precision, gamma_i^(k), for the current trial. Hence, in the PE step, it needs to perform only the following calculations:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{align} \\deltai^{(k)} &= \\mui^{(k)} - \\hat{\\mu}i^{(k)}\\\n\\Deltai^{(k)} &= \\frac{\\hat{\\pi}i^{(k)}}{\\pi{i}^{(k)}} + \\hat{\\pi}i^{(k)} (\\deltai^{(k)})^2 - 1. \\end{align} $","category":"page"},{"location":"theory/vope/#Prediction-Step","page":"Computations for VOPE coupling","title":"Prediction Step","text":"","category":"section"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Still assuming that Node i is the volatility child of Node i+1, the PREDICTION step consists of the following simple computations:","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"$","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"\\begin{align} \\hat{\\mu}i^{(k+1)} &= \\mui^{(k)}\\\n\\nui^{(k+1)} &= \\exp(\\kappai \\mu{i+1}^{(k)} + \\omegai)\\\n\\hat{\\pi}i^{(k+1)} &= \\frac{1}{\\frac{1}{\\pii^{(k)}} + \\nui^{(k+1)} }\\\n\\gammai^{(k+1)} &= \\nui^{(k+1)} \\hat{\\pi}i^{(k+1)} \\end{align} $","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Thus, the prediction for trial k+1 depends again only on receiving the posterior mean of Node i+1 on trial k, and knowing the Node's own posteriors.","category":"page"},{"location":"theory/vope/","page":"Computations for VOPE coupling","title":"Computations for VOPE coupling","text":"Note that if Node~i additionally has a VAPE parent node, the prediction of the new mean, hatmu_i^k+1 would also depend on the posterior mean of that value parent (cf. PREDICTION step for VAPE coupling).","category":"page"},{"location":"theory/genmodel/#The-generative-model-of-the-HGF:-Volatility-vs.-value-coupling","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"","category":"section"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"In the generative model of the HGF, (hidden) states of the world perform Gaussian random walks in time and can produce outcomes which are perceived by an observer as inputs. States can influence each other via volatility coupling or via value coupling.","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"In the classical 3-level binary HGF as presented in Mathys (2011), the two states of interest, x_2 and x_3, are coupled to each other via volatility coupling, which means that for state x_2, the mean of the Gaussian random walk on trial k is given by its previous value x_2^(k-1), while the step size (or variance) depends on the current value of the higher level state, x_3^(k):","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"x_2^{(k)} \\sim \\mathcal{N}(x_2^{(k)} | x_2^{(k-1)}, \\, f(x_3^{(k)})),","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"where the exact dependency is of the form","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"f(x_3^{(k)}) = \\exp(\\kappa_2 x_3^{(k)} + \\omega_2).","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"However, a higher-level state can also have influence on a lower-level state by influencing its mean. In that case, the mean of the Gaussian random walk at one level is a function not only of its own previous value, but also the current value of the higher-level state (with step size either constant or a function of another state):","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"x_2^{(k)} \\sim \\mathcal{N}(x_2^{(k)} | x_2^{(k-1)} + \\alpha_{4,2} x_4^{(k)}, \\, \\exp(\\omega_2)),","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"which means constant step size, or","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"x_2^{(k)} \\sim \\mathcal{N}(x_2^{(k)} | x_2^{(k-1)} + \\alpha_{4,2} x_4^{(k)}, \\, \\exp(\\kappa_2 x_3^{(k)} + \\omega_2)).","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"In other words, any given state in the world can be modelled as having a volatility parent state, a value parent state, or both, or none (in which case it evolves as a Gaussian random walk around its previous value with fixed step size). Consequently, when inferring on the evolution of these states, the exact belief update equations (which include the computation of new predictions, posterior values, and prediction errors, and represent an approximate inversion of this generative model, see Mathys (2011) depend on the nature of the coupling of a given state with its parent and children states. In particular, the nodes that implement the belief updates will communicate with their value parents via value prediction errors, or VAPEs, and via volatility prediction errors, or VOPEs, with their volatility parents.","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"(Image: Figure1) An example of a generative model of sensory inputs with six hidden states. Volatility coupling is depicted with dashed lines, value coupling with straight lines.","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"In Figure 1 we have drawn an example setup with six different environmental states and one outcome. Here, we have denoted states that function as value parents for other states as x_i, and states that function as volatility parents as checkx_i. Volatility coupling is depicted by curvy arrows, value coupling by straight arrows, and observable outcomes are linked to their hidden states via double arrows.","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"For the example illustrated in Figure 1 the following equations describe the generative model:","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"$","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"\\begin{align} u^{(k)} &\\sim \\mathcal{N}(u^{(k)} | x1^{(k)}, \\, \\sigmau) \\\nx1^{(k)}           &\\sim \\mathcal{N}(x1^{(k)} | x1^{(k-1)} + \\alpha{2,1} x2^{(k)}, \\, \\exp(\\kappa1 \\check{x}1^{(k)} + \\omega1)) \\\n\\check{x}1^{(k)}   &\\sim \\mathcal{N}(\\check{x}1^{(k)} | \\check{x}1^{(k-1)} + \\alpha{3,\\check{1}} x3^{(k)}, \\, \\exp(\\omega{\\check{1}})) \\\nx2^{(k)}           &\\sim \\mathcal{N}(x2^{(k)} | x2^{(k-1)}, \\, \\exp(\\kappa2 \\check{x}2^{(k)} + \\omega2)) \\\n\\check{x}2^{(k)}   &\\sim \\mathcal{N}(\\check{x}2^{(k)} | \\check{x}2^{(k-1)}, \\, \\exp(\\omega{\\check{2}})) \\\nx3^{(k)}           &\\sim \\mathcal{N}(x3^{(k)} | x3^{(k-1)}, \\, \\exp(\\kappa3 \\check{x}3^{(k)} + \\omega3)) \\\n\\check{x}3^{(k)}   &\\sim \\mathcal{N}(\\check{x}3^{(k)} | \\check{x}3^{(k-1)}, \\, \\exp(\\omega{\\check{3}})) \\\n\\end{align} $","category":"page"},{"location":"theory/genmodel/","page":"The generative model of the HGF: Volatility vs. value coupling","title":"The generative model of the HGF: Volatility vs. value coupling","text":"Note that in this example, all states that are value parents of other states (or outcomes) have their own volatility parent, while states that are volatility parents to other nodes either have a value parent (as state checkx_1), or no parents (as states checkx_2 and checkx_3). This is deliberately so, and we will see these two motifs - every state of a hierarchy has its own volatility estimation, and volatility states only have value parents - reappear in the following chapters.","category":"page"},{"location":"theory/node/#Belief-updates-in-the-HGF:-Computations-of-nodes","page":"Belief updates in the HGF: Computations of nodes","title":"Belief updates in the HGF: Computations of nodes","text":"","category":"section"},{"location":"theory/node/","page":"Belief updates in the HGF: Computations of nodes","title":"Belief updates in the HGF: Computations of nodes","text":"In the approximate inversion of the generative model presented above, (Mathys, 2011) derived a set of simple, one-step update equations that represent changes in beliefs about the hidden states specified in the generative model. For each state, a belief is held (and updated for every new input) by the agent and described as a Gaussian distribution, fully characterized by its mean mu_i^(k) and its inverse variance, or precision, pi_i^(k) on a given trial k. We conceptualize each belief as a node in a network, where belief updates involve computations within nodes as well as message passing between nodes. The computations of any node within an experimental trial can be ordered in time as shown in the box:","category":"page"},{"location":"theory/node/","page":"Belief updates in the HGF: Computations of nodes","title":"Belief updates in the HGF: Computations of nodes","text":"Node i at trial k(compute mathrmprediction^(k)_i)   &larr; receive mathrmPE^(k)_i-1 from mathrmnode_i-1UPDATE step   compute mathrmposterior^(k)_i   given: mathrmPE^(k)_i-1 and mathrmprediction^(k)_i   &rarr; send mathrmposterior^(k)_i to mathrmnode_i-1PE step   compute mathrmPE^(k)_i   given: mathrmprediction^(k)_i and mathrmposterior^(k)_i   &rarr; send mathrmPE^(k)_i to mathrmnode_i+1   &larr; receive mathrmposterior^(k)_i+1 from mathrmnode_i+1  PREDICTION step   compute mathrmprediction^(k+1)_i   given: mathrmposterior^(k)_i and mathrmposterior^(k)_i+1  ","category":"page"},{"location":"theory/node/","page":"Belief updates in the HGF: Computations of nodes","title":"Belief updates in the HGF: Computations of nodes","text":"The exact computations in each step depend on the nature of the coupling (via VAPEs vs. VOPEs) with the parent and children nodes and will be outlined in the following two chapters.","category":"page"},{"location":"theory/node/","page":"Belief updates in the HGF: Computations of nodes","title":"Belief updates in the HGF: Computations of nodes","text":"Note that we have placed the PREDICTION step in the end of a trial. This is because usually, we think about the beginning of a trial as starting with receiving a new input, and of a prediction as being present before that input is received. However, in some variants of the HGF the prediction also depends on the time that has passed in between trials, which is something that can only be evaluated once the new input arrives - hence the additional computation of the (current) prediction in the beginning of the trial. Conceptually, it makes most sense to think of the prediction as happening continuously between trials. For implementational purposes, it is however most convenient to only compute the prediction once the new input (and with it its arrival time) enters. This ensures both that the posterior means of parent nodes have had enough time to be sent back to their children for preparation for the new input, and that the arrival time of the new input can be taken into account appropriately.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HierarchicalGaussianFiltering","category":"page"},{"location":"#HierarchicalGaussianFiltering","page":"Home","title":"HierarchicalGaussianFiltering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HierarchicalGaussianFiltering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generative model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Node","category":"page"},{"location":"","page":"Home","title":"Home","text":"VAPE","category":"page"},{"location":"","page":"Home","title":"Home","text":"VOPE","category":"page"},{"location":"#Using-the-Package","page":"Home","title":"Using the Package","text":"","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#List-of-Functions","page":"Home","title":"List of Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [HierarchicalGaussianFiltering]","category":"page"},{"location":"#HierarchicalGaussianFiltering.AbstractInputNode","page":"Home","title":"HierarchicalGaussianFiltering.AbstractInputNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.AbstractNode","page":"Home","title":"HierarchicalGaussianFiltering.AbstractNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.AbstractStateNode","page":"Home","title":"HierarchicalGaussianFiltering.AbstractStateNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryInputNode","page":"Home","title":"HierarchicalGaussianFiltering.BinaryInputNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryInputNodeHistory","page":"Home","title":"HierarchicalGaussianFiltering.BinaryInputNodeHistory","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryInputNodeState","page":"Home","title":"HierarchicalGaussianFiltering.BinaryInputNodeState","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryStateNode","page":"Home","title":"HierarchicalGaussianFiltering.BinaryStateNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryStateNodeHistory","page":"Home","title":"HierarchicalGaussianFiltering.BinaryStateNodeHistory","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.BinaryStateNodeState","page":"Home","title":"HierarchicalGaussianFiltering.BinaryStateNodeState","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousInputNode","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousInputNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousInputNodeHistory","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousInputNodeHistory","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousInputNodeParams","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousInputNodeParams","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousInputNodeState","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousInputNodeState","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousStateNode","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousStateNode","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousStateNodeHistory","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousStateNodeHistory","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousStateNodeParams","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousStateNodeParams","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.ContinuousStateNodeState","page":"Home","title":"HierarchicalGaussianFiltering.ContinuousStateNodeState","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.HGF","page":"Home","title":"HierarchicalGaussianFiltering.HGF","text":"\n\n\n\n","category":"type"},{"location":"#HierarchicalGaussianFiltering.OrderedNodes","page":"Home","title":"HierarchicalGaussianFiltering.OrderedNodes","text":"\n\n\n\n","category":"type"},{"location":"#ActionModels.get_history-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"ActionModels.get_history","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_history-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"ActionModels.get_history","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_history-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String}}","page":"Home","title":"ActionModels.get_history","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_history-Tuple{HierarchicalGaussianFiltering.HGF, Vector}","page":"Home","title":"ActionModels.get_history","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_history-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"ActionModels.get_history","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_states-Tuple{HierarchicalGaussianFiltering.AbstractNode, String}","page":"Home","title":"ActionModels.get_states","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_states-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"ActionModels.get_states","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_states-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String}}","page":"Home","title":"ActionModels.get_states","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_states-Tuple{HierarchicalGaussianFiltering.HGF, Vector}","page":"Home","title":"ActionModels.get_states","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.get_states-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"ActionModels.get_states","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.give_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Array}","page":"Home","title":"ActionModels.give_inputs!","text":"give_inputs!(hgf::HGF, inputs::Array)\n\nFunction for inputting multiple observations to an hgf. Input is structured as an array, with one column per input node and one row per timestep.\n\n\n\n\n\n","category":"method"},{"location":"#ActionModels.give_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Real}","page":"Home","title":"ActionModels.give_inputs!","text":"give_inputs!(hgf::HGF, inputs::Number)\n\nFunction for inputting multiple observations to an hgf. Input is a single value.\n\n\n\n\n\n","category":"method"},{"location":"#ActionModels.give_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Vector}","page":"Home","title":"ActionModels.give_inputs!","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.plot_predictive_simulation-Tuple{HierarchicalGaussianFiltering.HGF, Union{Dict, MCMCChains.Chains}, Union{String, Tuple}, Vector}","page":"Home","title":"ActionModels.plot_predictive_simulation","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.plot_trajectory!-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"ActionModels.plot_trajectory!","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.plot_trajectory!-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String}}","page":"Home","title":"ActionModels.plot_trajectory!","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.plot_trajectory-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"ActionModels.plot_trajectory","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.plot_trajectory-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String}}","page":"Home","title":"ActionModels.plot_trajectory","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.premade_agent","page":"Home","title":"ActionModels.premade_agent","text":"premade_agent(model_name::String, hgf::HGF, params_list::NamedTuple = (;))\n\nFunction for making a premade agent, where a HGF is passed as a separate argument.\n\n\n\n\n\n","category":"function"},{"location":"#ActionModels.reset!-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"ActionModels.reset!","text":"\n\n\n\n","category":"method"},{"location":"#ActionModels.set_params!-Tuple{HierarchicalGaussianFiltering.HGF, Dict}","page":"Home","title":"ActionModels.set_params!","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_auxiliary_prediction_precision-Tuple{HierarchicalGaussianFiltering.AbstractInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_auxiliary_prediction_precision","text":"calculate_auxiliary_prediction_precision(self::AbstractInputNode)\n\nAn input nodes auxiliary precision is always 1.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_auxiliary_prediction_precision-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_auxiliary_prediction_precision","text":"calculate_auxiliary_prediction_precision(self::AbstractNode)\n\nCalculates a node's auxiliary prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_mean-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_mean","text":"calculate_posterior_mean(self::AbstractNode, value_children, volatility_children)\n\nCalculates a node's posterior mean.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_mean-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_mean","text":"calculate_posterior_mean(self::BinaryStateNode, value_children, volatility_children)\n\nCalculates a node's posterior mean.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_mean_value_child_increment-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_mean_value_child_increment","text":"calculate_posterior_mean_value_child_increment(\n    self::AbstractNode,\n    child::AbstractNode)\n\nCalculates the posterior mean update term for a single continuous value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_mean_value_child_increment-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_mean_value_child_increment","text":"calculate_posterior_mean_value_child_increment(\n    self::AbstractNode,\n    child::BinaryStateNode)\n\nCalculates the posterior mean update term for a single binary value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_mean_volatility_child_increment-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_mean_volatility_child_increment","text":"calculate_posterior_mean_volatility_child_increment(\n    self::AbstractNode,\n    child::Any)\n\nCalculates the posterior mean update term for a single continuos volatility child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_precision-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_precision","text":"calculate_posterior_precision(\n    self::AbstractNode,\n    value_children,\n    volatility_children)\n\nCalculates a node's posterior precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_precision-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_precision","text":"calculate_posterior_precision(\n    self::BinaryStateNode,\n    value_children,\n    volatility_children)\n\nCalculates a binary node's posterior precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_precision_vape-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_precision_vape","text":"calculate_posterior_precision_vape(\n    self::AbstractNode,\n    child::AbstractNode)\n\nCalculates the posterior precision update term for a single continuous value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_precision_vape-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_precision_vape","text":"calculate_posterior_precision_vape(\n    self::AbstractNode,\n    child::BinaryStateNode)\n\nCalculates the posterior precision update term for a single binary value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_posterior_precision_vope-Tuple{HierarchicalGaussianFiltering.AbstractNode, HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_posterior_precision_vope","text":"calculate_posterior_precision_vope(\n    posterior_precision::Real,\n    self::AbstractNode,\n    volatility_children::Any)\n\nCalculates the posterior precision update term for a single continuous volatility child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_mean-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_mean","text":"calculate_prediction_mean(self::AbstractNode, value_parent::Any)\n\nCalculates a node's prediction mean.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_mean-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_mean","text":"calculate_prediction_mean(self::AbstractNode, value_parent::Any)\n\nCalculates a binary state node's prediction mean.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_precision-Tuple{HierarchicalGaussianFiltering.AbstractInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_precision","text":"calculate_prediction_precision(self::ContinuousInputNode)\n\nCalculates an input node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_precision-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_precision","text":"calculate_prediction_precision(self::ContinuousStateNode)\n\nCalculates a node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_precision-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_precision","text":"calculate_prediction_precision(self::BinaryStateNode)\n\nCalculates a binary state node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_prediction_volatility-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_prediction_volatility","text":"calculate_prediction_volatility(self::AbstractNode,  volatility_parents::Any)\n\nCalculates a node's prediction volatility.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_value_prediction_error-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::AbstractNode)\n\nCalculate's a state node's value prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_value_prediction_error-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::BinaryInputNode)\n\nCalculates the prediciton error of a binary input node with finite precision\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_value_prediction_error-Tuple{HierarchicalGaussianFiltering.ContinuousInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::ContinuousInputNode, value_parents::Any)\n\nCalculate's an input node's value prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_volatility_prediction_error-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_volatility_prediction_error","text":"calculate_volatility_prediction_error(self::AbstractNode)\n\nCalculates a state node's volatility prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.calculate_volatility_prediction_error-Tuple{HierarchicalGaussianFiltering.ContinuousInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.calculate_volatility_prediction_error","text":"calculate_volatility_prediction_error(self::ContinuousInputNode, value_parents::Any)\n\nCalculates an input node's volatility prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.check_hgf-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.check_hgf","text":"check_hgf(node::BinaryInputNode)\n\nFunction for checking the validity of a single binary input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.check_hgf-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.check_hgf","text":"check_hgf(node::BinaryStateNode)\n\nFunction for checking the validity of a single binary state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.check_hgf-Tuple{HierarchicalGaussianFiltering.ContinuousInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.check_hgf","text":"check_hgf(node::ContinuousInputNode)\n\nFunction for checking the validity of a single continuous input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.check_hgf-Tuple{HierarchicalGaussianFiltering.ContinuousStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.check_hgf","text":"check_hgf(node::ContinuousStateNode)\n\nFunction for checking the validity of a single continous state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.check_hgf-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"HierarchicalGaussianFiltering.check_hgf","text":"Function for checking if the specified HGF structure is valid\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.enter_node_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Dict{String, Real}}","page":"Home","title":"HierarchicalGaussianFiltering.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGF, inputs::Dict)\n\nFunction for entering multiple inputs, structured as a dictionary, to multiple input nodes.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.enter_node_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Real}","page":"Home","title":"HierarchicalGaussianFiltering.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGF, input::Number)\n\nFunction for entering a single input to a single input node. Can either take a single number, or a tuple which also includes the precision of the input.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.enter_node_inputs!-Tuple{HierarchicalGaussianFiltering.HGF, Vector{Real}}","page":"Home","title":"HierarchicalGaussianFiltering.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGF, inputs::Vector)\n\nFunction for entering multiple inputs, structured as a vector, to multiple input nodes.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_prediction","page":"Home","title":"HierarchicalGaussianFiltering.get_prediction","text":"\n\n\n\n","category":"function"},{"location":"#HierarchicalGaussianFiltering.get_prediction-2","page":"Home","title":"HierarchicalGaussianFiltering.get_prediction","text":"get_prediction(hgf::HGF, node_name::String)\n\nGets the full prediction for the next timestep for a specified node in an HGF.\n\n\n\n\n\n","category":"function"},{"location":"#HierarchicalGaussianFiltering.get_prediction-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"HierarchicalGaussianFiltering.get_prediction","text":"get_prediction(node::AbstractNode)\n\nGets the full prediction for the next timestep for a single node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{ActionModels.Agent, String}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{ActionModels.Agent}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"get_surprise(node::BinaryInputNode)\n\nCalculates the surprise of a binary input node on seeing the last input.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{HierarchicalGaussianFiltering.ContinuousInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"get_surprise(node::ContinuousInputNode)\n\nCalculates the surprise of an input node on seeing the last input. Implements the equation: −log(p(u(k)))= 1(log(2π)−log(πˆ(k))+πˆ(k)(u(k) −μˆ(k) )2)\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"getsurprise(hgf::HGF, nodename::String = \"u\")\n\nCalculates the surprisal of a specified input node in an HGF.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.get_surprise-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"HierarchicalGaussianFiltering.get_surprise","text":"getsurprise(hgf::HGF, nodename::String = \"u\")\n\nCalculates the surprisal of a specified input node in an HGF.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.hgf_binary_softmax_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.hgf_binary_softmax_action","text":"hgf_binary_softmax_action(agent, input)\n\nAction model which gives a binary action. The action probability is the softmax of a specified state of a node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.hgf_gaussian_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.hgf_gaussian_action","text":"hgf_gaussian_action(agent, input)\n\nAction model which reports a given HGF state with Gaussian noise.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.hgf_unit_square_sigmoid_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.hgf_unit_square_sigmoid_action","text":"unit_square_sigmoid_action(agent, input)\n\nAction model which gives a binary action. The action probability is the unit square sigmoid of a specified state of a node.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.init_hgf-Tuple{}","page":"Home","title":"HierarchicalGaussianFiltering.init_hgf","text":"function init_hgf(\n    default_params,\n    input_nodes,\n    state_nodes,\n    edges,\n    update_order = false,\n)\n\nFunction for initializing the structure of an HGF model.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.init_node-Tuple{Any, Any, Any}","page":"Home","title":"HierarchicalGaussianFiltering.init_node","text":"init_node(input_or_state_node, node_defaults, node_info)\n\nFunction for creating a node, given specifications\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_JGET-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_JGET","text":"premade_JGET(params_list, starting_state_list)\n\nThe JGET model. It has a single continuous input node u, with a value parent x1, and a volatility parent x3. x1 has volatility parent x2, and x3 has a volatility parent x4.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_binary_2level-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_binary_2level","text":"premade_binary_2level(params_list, starting_state_list)\n\nThe standard binary 2 level HGF model\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_binary_3level-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_binary_3level","text":"premade_binary_3level(params_list, starting_state_list)\n\nThe standard binary 3 level HGF model\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_continuous_2level-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_continuous_2level","text":"premade_continuous_2level(params_list, starting_state_list)\n\nThe standard 2 level HGF. It has a continous input node U, with a single value parent x1, which in turn has a single volatility parent x2.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_hgf","page":"Home","title":"HierarchicalGaussianFiltering.premade_hgf","text":"function premade_hgf(\n    model_name,\n    params,\n    starting_state,\n)\n\nFunction for initializing the structure of an HGF model.\n\n\n\n\n\n","category":"function"},{"location":"#HierarchicalGaussianFiltering.premade_hgf_binary_softmax-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_hgf_binary_softmax","text":"premade_hgf_binary_softmax(\n    hgf = premade_hgf(\"binary_3level\"),\n    action_precision = 1,\n    target_node = \"x1\",\n    target_state = \"posterior_mean\",\n)\n\nFunction that initializes as premade HGF binary softmax action agent\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_hgf_gaussian-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_hgf_gaussian","text":"premade_hgf_gaussian(\n    hgf = premade_hgf(\"continuous_2level\"),\n    action_precision = 1,\n    target_node = \"x1\",\n    target_state = \"posterior_mean\",\n)\n\nFunction that initializes as premade HGF gaussian action agent\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_hgf_multiple_actions-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_hgf_multiple_actions","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.premade_hgf_unit_square_sigmoid-Tuple{Dict}","page":"Home","title":"HierarchicalGaussianFiltering.premade_hgf_unit_square_sigmoid","text":"premade_hgf_unit_square_sigmoid(\n    hgf = premade_hgf(\"binary_3level\"),\n    action_precision = 1,\n    target_node = \"x1\",\n    target_state = \"posterior_mean\",\n)\n\nFunction that initializes as premade HGF binary softmax action agent\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_hgf!-Tuple{HierarchicalGaussianFiltering.HGF, Union{Dict{String, Real}, Real, Vector{Real}}}","page":"Home","title":"HierarchicalGaussianFiltering.update_hgf!","text":"update_hgf!(hgf::HGF, inputs) \n\nFunction for updating all nodes in an HGF hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_hgf_binary_softmax_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.update_hgf_binary_softmax_action","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_hgf_gaussian_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.update_hgf_gaussian_action","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_hgf_multiple_actions-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.update_hgf_multiple_actions","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_hgf_unit_square_sigmoid_action-Tuple{ActionModels.Agent, Any}","page":"Home","title":"HierarchicalGaussianFiltering.update_hgf_unit_square_sigmoid_action","text":"\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_input!-Tuple{HierarchicalGaussianFiltering.AbstractInputNode, Real}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_input!","text":"update_node_input!(self::ContinuousInputNode, input::Real)\n\nFunction for updating the input for a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_posterior!-Tuple{HierarchicalGaussianFiltering.AbstractStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_posterior!","text":"update_node_posterior!(self::ContinuousStateNode)\n\nFunction for updating the posterior of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_prediction!-Tuple{HierarchicalGaussianFiltering.AbstractInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_prediction!","text":"update_node_prediction!(self::ContinuousInputNode)\n\nFunction for updating the posterior of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_prediction!-Tuple{HierarchicalGaussianFiltering.AbstractStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_prediction!","text":"update_node_prediction!(self::ContinuousStateNode)\n\nFunction for updating the prediction for a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_prediction!-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_prediction!","text":"update_node_prediction!(self::BinaryInputNode)\n\nThe prediction precision is constant for binary input nodes, so nothing is done here.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_prediction!-Tuple{HierarchicalGaussianFiltering.BinaryStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_prediction!","text":"update_node_prediction!(self::BinaryStateNode)\n\nFunction for updating the prediction for a single Binary state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_value_prediction_error!-Tuple{HierarchicalGaussianFiltering.AbstractInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_value_prediction_error!","text":"update_node_value_prediction_error!(self::ContinuousInputNode)\n\nFunction for updating the value prediction error of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_value_prediction_error!-Tuple{HierarchicalGaussianFiltering.AbstractStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_value_prediction_error!","text":"Function for updating the value prediction error of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_value_prediction_error!-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_value_prediction_error!","text":"update_node_value_prediction_error!(self::BinaryInputNode)\n\nFunction for updating the value prediction error of a single input node. \n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_volatility_prediction_error!-Tuple{HierarchicalGaussianFiltering.AbstractInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_volatility_prediction_error!","text":"update_node_volatility_prediction_error!(self::ContinuousInputNode)\n\nFunction for updating the volatility prediction error of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_volatility_prediction_error!-Tuple{HierarchicalGaussianFiltering.AbstractStateNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_volatility_prediction_error!","text":"Function for updating the volatility prediction error of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalGaussianFiltering.update_node_volatility_prediction_error!-Tuple{HierarchicalGaussianFiltering.BinaryInputNode}","page":"Home","title":"HierarchicalGaussianFiltering.update_node_volatility_prediction_error!","text":"update_node_volatility_prediction_error!(self::BinaryInputNode)\n\nThere is no volatility prediction error for binary input nodes.\n\n\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.AbstractNode}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.HGF, String}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String, String}}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.HGF, Tuple{String, String}}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.HGF, Vector}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"#MCMCChains.get_params-Tuple{HierarchicalGaussianFiltering.HGF}","page":"Home","title":"MCMCChains.get_params","text":"\n\n\n\n","category":"method"},{"location":"theory/vape/#Computations-for-VAPE-coupling","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"","category":"section"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"The exact computations of the UPDATE depend on the nature of the coupling with the child node(s), while both the PE step and the PREDICTION step depend on the coupling with the parent node(s).","category":"page"},{"location":"theory/vape/#Update-Step","page":"Computations for VAPE coupling","title":"Update Step","text":"","category":"section"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"If Node~i is the value parent of Node i-1, then the following update equations apply to Node~i:","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"$","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"\\begin{align} \\pii^{(k)} &= \\hat{\\pi}i^{(k)} + \\alpha{i-1,i}^2 \\hat{\\pi}{i-1}^{(k)}\\\n\\mui^{(k)} &= \\hat{\\mu}i^{(k)} + \\frac{\\alpha{i-1,i}^2 \\hat{\\pi}{i-1}^{(k)}} {\\alpha{i-1,i}^2 \\hat{\\pi}{i-1}^{(k)} + \\hat{\\pi}{i}^{(k)}} \\delta{i-1}^{(k)} \\end{align} $","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"We note here that we can let the update of the precision happen first, and therefore use it for the update of the mean:","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"$","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"\\begin{align} \\pii^{(k)} &= \\hat{\\pi}i^{(k)} + \\alpha{i-1,i}^2 \\hat{\\pi}{i-1}^{(k)}\\\n\\mui^{(k)} &= \\hat{\\mu}i^{(k)} + \\frac{\\alpha{i-1,i}^2 \\hat{\\pi}{i-1}^{(k)}} {\\pii^{(k)}} \\delta{i-1}^{(k)} \\end{align} $","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"In sum, at the time of the update, Node~i needs to have access to the following quantities:","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Its own predictions: hatmu_i^(k), hatpi_i^(k)  \nCoupling strength: alpha_i-1i  \nFrom level below: delta_i-1^(k), hatpi_i-1^(k)  ","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"All of these are available at the time of the update. Node~i therefore only needs to receive the PE and the predicted precision from the level below to perform its update.","category":"page"},{"location":"theory/vape/#Prediction-Error-Step","page":"Computations for VAPE coupling","title":"Prediction Error Step","text":"","category":"section"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"We will assume in the following, that Node~i is the value child of Node i+1. Then the following quantities have to be sent up to Node i+1 (cf. necessary information from level below in a value parent):","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Predicted precision: hatpi_i^(k)\nPrediction error: delta_i^(k)","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Node~i has already performed the PREDICTION step on the previous trial, so it has already computed the predicted precision of the current trial,~hatpi_i^(k). Hence, in the PE step, it needs to perform only the following calculation: $ \\begin{equation} \\deltai^{(k)} = \\mui^{(k)} - \\hat{\\mu}_i^{(k)} \\end{equation} $","category":"page"},{"location":"theory/vape/#Prediction-Step","page":"Computations for VAPE coupling","title":"Prediction Step","text":"","category":"section"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Still assuming that Node~i is the value child of Node i+1, the PREDICTION step consists of the following computations:","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"$","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"\\begin{align} \\hat{\\mu}i^{(k+1)} &= \\mui^{(k)} + \\alpha{i,i+1} \\mu{i+1}^{(k)}\\\n\\hat{\\pi}i^{(k+1)} &= \\frac{1}{\\frac{1}{\\pii^{(k)}} + \\nu_i^{(k+1)} } \\end{align} $","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"with","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"$","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"\\begin{equation} \\nui^{(k+1)} = \\exp(\\omegai). \\end{equation} $","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Note that if Node~i additionally has a VOPE parent node, the estimated volatility nu_i^(k+1) that enters the precision update would also depend on the posterior mean of that volatility parent (cf. PREDICTION step for VOPE coupling).","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"In general, the prediction of the mean will depend only on whether Node~i has a value parent or not, whereas the prediction of the precision only depends on whether Node~i has a volatility parent or not.","category":"page"},{"location":"theory/vape/","page":"Computations for VAPE coupling","title":"Computations for VAPE coupling","text":"Thus, the PREDICTION step only depends on knowing the node's own posteriors and receiving the value parent's posterior in time before the new input arrives.","category":"page"}]
}
